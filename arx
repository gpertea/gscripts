#!/bin/env perl
use strict;
use Getopt::Std;
use File::Basename; #for basename, dirname
use POSIX "sys_wait_h"; # mostly for the handy uname() function
use Cwd qw(abs_path cwd);
use Fcntl qw(:DEFAULT :seek); #mostly for the SEEK constants
my $usage=q{arx : array job executor in current working directory
Usage:
  arx <command> [options]
  Array job executor for SLURM (or for GNU parallel, when used with -P).
  Usage example:
    arx sub -a 1- -J bsp45 -m 32G -l logs task_fq2cram.sh samples.manifest
 Or use -C option to execute each line of <cmdfile> as a task in an array job
    arx sub -C <cmdfile>
};
## -I to create the line index for the 2nd argument in case of JARR?
## double-dash recognized options for SLURM (anything else is just passed to sbatch)
# -c, --cpus-per-task=<ncpus>
# -a, --array=<indexes>
# -J, --job-name=<jobname>
# --mem=<size>[units] (-m also recognized as a shortcut by arx)
# -o, --output=<filename_pattern> #default file name is "slurm-%A_%a.out", "%A" is replaced by the job ID and "%a" with the array index
# -e, --error=<filename_pattern>
# --mail-type, 
# --mail-user (=> -M shortcut added by arx, also auto enables '--mail-type END,FAIL')
my @cmds = qw/status st run runline sub submit qsub watch/;
my %cmds; 
@cmds{@cmds}=();

die("$usage\n") unless exists($cmds{$ARGV[0]});

my $cmd=shift(@ARGV);

my @ddash; # double dash arguments
my $i = 0;
while ($i < @ARGV) {
  if ($ARGV[$i] =~ /^--([^=]+)=(.*)/) {# '=' found, split on it and add the key-value pair
      push @ddash, [$1, $2];
      splice(@ARGV, $i, 1); # remove the current item from @ARGV
  } elsif ($ARGV[$i] =~ /^--(.+)/) {# no '=' is found but the argument starts with '--'
      my $k=$1; my $r=1;
      if ($i<$#ARGV && $ARGV[$i + 1]!~m/^-/) {
         push @ddash, [$k, $ARGV[$i + 1]]; ## assume the next argument is the value
         $r++;
      } else {  push @ddash, [ $k, '']   }
      splice(@ARGV, $i, $r); # remove this argument and the next one from @ARGV
  } else {  $i++ } # just move to the next argument
}

getopts('MPCJ:l:a:m:o:e:c:') || die($usage."\n");
my $JGRID=$Getopt::Std::opt_P ? 'par' :'slurm';
#my $ge=lc($Getopt::Std::opt_g) || 'slurm'; # grid engine 
my $PWD=abs_path(cwd()); #from Cwd module
my $HOSTNAME = (&POSIX::uname)[1];

chomp($HOSTNAME);
$HOSTNAME=lc($HOSTNAME);

my $HOST=$HOSTNAME;

($HOST)=($HOST=~m/^([\w\-]+)/);
$ENV{HOST}=$HOST;
$ENV{MACHINE}=$HOST;
$ENV{HOSTNAME}=$HOSTNAME;

my $HOME=$ENV{HOME}; 
my $JOB=$ENV{'SLURM_JOBID'} || '0';
#my $JOB=$ENV{'JOB_ID'} || '0';
my $TASK=$ENV{'SLURM_ARRAY_TASK_ID'} || '0';
#$TASK=$ENV{'SGE_TASK_ID'} unless $TASK; ## support SGE?

my ($JARR, $JMEM, $JCPUS, $JMAIL, $JMAILTYPE, $JNAME, $JLOG, $JERRLOG);
my @ddpass; ## pass-through options
foreach my $dd (@ddash) {
  if ($$dd[0] eq 'array') { $JARR=$$dd[1] 
  } elsif ($$dd[0] eq 'cpus-per-task') {  $JCPUS=$$dd[1] 
  } elsif ($$dd[0] eq 'mem') {  $JMEM=$$dd[1] 
  } elsif ($$dd[0] eq 'mail-type') {  $JMAILTYPE=$$dd[1] 
  } elsif ($$dd[0] eq 'mail-user') {  $JMAIL=$$dd[1] 
  } elsif ($$dd[0] eq 'job-name') {  $JNAME=$$dd[1] 
  } elsif ($$dd[0] eq 'output') {  $JLOG=$$dd[1] 
  } elsif ($$dd[0] eq 'error') {  $JERRLOG=$$dd[1] }
  else { push @ddpass, "--$$dd[0]=$$dd[1]" } # pass-through unrecognized options
}

$JARR=$Getopt::Std::opt_a if $Getopt::Std::opt_a;
$JMEM=$Getopt::Std::opt_m if $Getopt::Std::opt_m;
$JCPUS=$Getopt::Std::opt_c if $Getopt::Std::opt_c;
my $mail=$Getopt::Std::opt_M;
if ($mail) {
  #$JMAIL=$Getopt::Std::opt_M; use the email from ~/.slurm/default
  $JMAILTYPE='END,FAIL' unless $JMAILTYPE;
}
$JNAME=$Getopt::Std::opt_J if $Getopt::Std::opt_J;
$JLOG=$Getopt::Std::opt_o if $Getopt::Std::opt_o;
$JERRLOG=$Getopt::Std::opt_e if $Getopt::Std::opt_e;

my $cmdfile=$Getopt::Std::opt_C; # execute each line as a command

my $JMDIR="$HOME/_jobs";
my $logdir=$Getopt::Std::opt_l;
if ($cmd eq 'status') {
   print STDERR "Using grid engine: $JGRID\n";
   if ($JGRID eq 'slurm') {
      print STDERR "job $JOB.$TASK on $HOST\n";
   }
} elsif ($cmd =~ m/^sub/i) { # submit job
   mkdir($JMDIR) unless -d $JMDIR;
   my @args=();
   if ($cmdfile) { # -C option
      $cmdfile=shift(@ARGV);
      die("Error: command file $cmdfile not found!") unless $cmdfile && -f $cmdfile;
      unless($JARR) {
        my $nlines=`wc -l < $cmdfile`;
        chomp($nlines);
        $JARR='1-'.$nlines;
      }
      @args=("$HOME/gscripts/task_linecmd.sh", $cmdfile);
   } else {
     die("Error: submit command requires a target script!\n") unless @ARGV>0;
     @args=@ARGV;
     ## index with linix
     system("linix  $args[1]");
   }
   if ($JARR=~m/\-$/ && -f $args[1]) { ## assume line-based job array is the argument
      my $nlines=`wc -l < $args[1]`;
      chomp($nlines);
      $JARR.=$nlines;
   }
   
   unless ($JLOG) {
     $logdir='logs' unless $logdir;
     mkdir($logdir) unless -d $logdir; # all my array jobs write logs in a 'logs' subdir of cwd!
     $JLOG=$logdir.'/arx-%A_%a.tlog';
   }
   $JERRLOG = $JLOG if ($JLOG && !$JERRLOG);

   unshift(@args, '-a '.$JARR) if $JARR;
   unshift(@args, '--mem='.$JMEM) if $JMEM;
   unshift(@args, '-c '.$JCPUS) if $JCPUS;
   unshift(@args, '--mail-user='.$JMAIL) if $JMAIL; # or could be picked up from ~/.slurm/default
   unshift(@args, '--mail-type='.$JMAILTYPE) if $JMAILTYPE;
   unshift(@args, '-J '.$JNAME) if $JNAME;
   unshift(@args, '-o '.$JLOG) if $JLOG;
   unshift(@args, '-e '.$JERRLOG) if $JERRLOG;
   unshift(@args, @ddpass);

   my $job=submit(@args);
     
   my ($sec, $min, $hour, $mday, $mon, $year) = localtime();
   my $jtime = sprintf("%02d%02d%02d_%02d%02d", $year % 100, $mon + 1, $mday, $hour, $min);
   $JMDIR.="/${jtime}.$job";
   mkdir($JMDIR);
   open(JINFO, ">$JMDIR/j_cmd") || die("Error creating $JMDIR/j_cmd\n");
   print JINFO 'sbatch '.join(' ',@args)."\n";
   print JINFO "#cwd: $PWD\n";
   close(JINFO);
   $logdir=abs_path($logdir);
   symlink($PWD, "$JMDIR/j_cwd");
   if (!$cmdfile) {
     symlink("$logdir", "$JMDIR/j_logs");
   }
   print STDERR "submitted job: $job (check $JMDIR)\n";
   #if ($mail) {
     my $jn=$JNAME ? "w_${JNAME}_$job" : "w_$job";
     @args=("-J $jn", "--dependency=afterany:$job -o j_$job.watcher.log --mail-type='END,FAIL'", __FILE__, "watch ${jtime}.$job");
     my $j=submit(@args);
     print STDERR " ..submitted watcher job $j :\n".join(' ', @args)."\n";
   #}
} elsif ($cmd eq 'watch') {
  # get summary info for watched job
  my $tjob=$ARGV[0];
  $JMDIR.="/$tjob";
  print STDERR "Job $tjob ended (see $JMDIR/j_cmd)\n";
  chdir($JMDIR) || die("Error chdir($JMDIR)\n");
  ##NOTE: task scripts SHOULD create logs: ~/_jobs/<jobID>/arx-%A_<taskID>.tlog
  my @tlogs=glob('j_logs/*_[0-9]*.*log');
  #print STDERR "tlogs array = ".join(', ',@tlogs)."\n";
  if (@tlogs>0) { #collect summary for all tasks
     my @terr; # tasks that failed
     foreach my $tlf (@tlogs) {
        my ($tid)=($tlf=~m/(\d+)\.t?log$/);
        open(TLOG, "<$tlf") || die("Error opening task log file $JMDIR/$tlf\n");
        seek(TLOG, -100, SEEK_END);
        my @last=<TLOG>;
        my $l=$last[-1]; #last line, should be shorter than 100 chars!
        push(@terr, $tid) unless ($l=~m/\b(done|ok|succeeded|finished)/i);
        close(TLOG);
     }
   open(TSUM, '>t_sum.txt') || die("Error creating $JMDIR/t_sum.txt\n");
   my $total_msg="total_tasks\t".scalar(@tlogs)."\n";
   print TSUM $total_msg;
   print STDERR $total_msg;
   if (@terr>0) {
      my $errtasks="error_tasks_list\t".join(',',@terr)."\n";
      print TSUM $errtasks;
      print STDERR $errtasks
   }
   close(TSUM);
  }
} elsif ($cmd eq 'run') { ## TODO : check implementation
  print "running task $TASK in ".$ENV{PWD}." with args: ".join(" ",@ARGV)."\n";
  while (<>) {
    $cmd=$_;
    last if $.==$TASK;
    $cmd='';
  }
  if (length($cmd)) {
   chomp($cmd);$cmd=~s/\s+$//;
   my $cl=length($cmd);
   print " executing command of len $cl:\n<$cmd>\n";
   system($cmd);
  } else {
    print " error: no cmd found for $TASK!\n";
  }
}

#------------------
sub submit {
  my $args=join(" ", @_);
  print STDERR ">> submitting:\nsbatch $args\n";
  my $s=`sbatch $args`;
  my ($jid)=($s=~m/ubmitted batch job (\d+)/);
  die("Error: errror at sbatch $args ") unless $jid;
  return $jid;
}

sub read_line { # use the lidx
    my ($reqlno, $ftxt, $fidx) = @_;
    open my $idx_fh, '<', $fidx or die "Could not open '$fidx': $!";
    my $index_offset = ($reqlno - 1) * 8;
    seek $idx_fh, $index_offset, SEEK_SET;
    read $idx_fh, my $record, 8;
    close $idx_fh;
    my ($lno, $offset, $clen) = unpack('S I S', $record);
    die "Error: line number mismatch in index file!\n" if !defined($lno) || $lno != $reqlno;
    open my $txt_fh, '<', $ftxt or die "Could not open '$ftxt': $!";
    seek($txt_fh, $offset, SEEK_SET) || die "Error seeking to $offset in $ftxt : $!\n";
    my $line='------------------------------------------------------------------';
    my $brd=read($txt_fh, $line, $clen); 
    die "Error reading line $reqlno from $ftxt : $!\n" if !defined($brd);
    close $txt_fh;
    print $line."\n";
}
