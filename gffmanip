#!/usr/bin/perl
use strict;
use Getopt::Std;
use FindBin;use lib $FindBin::Bin;

my $usage = q/Usage:
 gffmanip [-v] [-o outrecords.txt] [-i [<attr>:]<tids.lst>] [-t <track>]\
 [-f <feature1>[,..]] [-r<regata> [-R][-E]] [-a [feat:]<attr>=<value>[;..] [-A]\
 [-k <attr1>[,..]] [-l <attrlist..>] [-m <IDchange.tab>] [-d <regdata>] \
 [[-y|-Y] <CDSdata.tab>] [-T] <gff\/gtf-input>

Filtering options:
 -S sort GFF records by location
 -C output only those transcripts having CDS features (protein coding)
 -cds like -C but output only the CDS features of the coding transcripts
    (discarding exon features)
 -r show only transcripts overlapping any of the region intervals given in 
    <regdata> which has the format:
       [<strand>]<chr>[:<start>-<end>[,<start2>-<end2>,...]]
 -X for -r option, only print records whose exon\/CDS segments overlap the given
    interval(s) (i.e. intron-only overlaps are not considered)
 -R for -r option, only print transcripts fully contained in any of the given 
    range interval(s)
 -i only shows transcripts whose IDs match any of the entries in the
    given file <ids.lst>; another attribute instead of ID can be used for 
    matching the list values if given as a <attr>: prefix to the file path;
    special "geneID:" prefix will apply gene ID filtering
 -a only shows transcripts which have the <attr> attribute with the value 
    <value>; multiple attribute\/value pairs can be given (semicolon delimited)
    and a record is printed if there is at least one attribute match (OR list);
    a <feature>: prefix can be used to specify which feature should be targeted
    (default: transcripts are targeted; the other option is "gene:")
 -A for the -a option, when multiple <attr>=<value> conditions are given 
    (comma delimited), all of them have to be present and matching (AND list)
 -v invert the filters (like grep's -v): print records that do NOT match any of
    the above transcript filtering options

 -f output only the specified GFF features, given as a comma-delimited
    list of strings (e.g. -f 'mRNA,ncRNA,exon,CDS') (doesn't work with -v)
 -F output only transcript-like records having exon or CDS features
    (doesn't work with -v)

Data modification options:
 -m replace contig\/chromosome IDs with different IDs, as specified in the given
    ID mapping table (a two column table mapping the old ID to the new ID)
    NOTE: renaming takes place when records are printed, *after* all the
    other filters have been applied
 -y assign\/modify the CDS and transcription strand of transcripts 
    found in the given tab delimited file of this format:
      transcriptID	new_strand	CDSinfo
    ..where CDSinfo can be either CDSstart:CDSstop or a comma delimited
    list of CDS features, e.g.: 70139455-70139671,70140524-70140552
 -Y same as -y, but only add CDS to records not having CDS info, never 
    change existing CDS!
Genomic deletion processing:
 -d contig\/chromosome region(s) deletion: discard the transcripts overlapping
    the given genomic region(s), shifting the coordinates of all the 
    features downstream from the deleted region(s). Example deletion:
    -d NC_029267.1:18816715-18860512

Output options:
 -K keep all GFF\/GTF attributes and preserve the input format
 -E for -K, discard exon\/CDS attributes (only keep transcript\/gene attrs)
 -Z merge close exons into a single exon (for intron size<4)
 -M adjust transcript boundaries to match min\/max coordinates of their exons
 -G adjust gene boundaries to match min\/max coordinates of their transcripts
 -k keep only the specified non-core GFF attributes in the output records
    (expects a comma delimited list of attribute names)
 -P preserve comments (lines starting with #)
 -T print GTF format (default is GFF3)
 -U decode url-encoded characters in attribute values and use safe replacements
 -l instead of GTF\/GFF, output a tab delimited file with the values of the
    specified attribute(s) for each record; special pseudo-attributes prefixed
    by @ are recognized: @chr, @start, @end, @strand, @numexons, @exons, @cds
    Hint: use with -F option to only show transcript-like records
 -t replace the string in the 2nd column with the given <track> text
 -V (verbose): show warnings or other potentially useful info
/;
umask 0002;
my @cmdline=($0, @ARGV);
getopts('vCXEFRAZPMGKVUTSo:c:f:r:t:i:a:k:l:m:y:Y:d:') || die($usage."\n");
die("${usage}Error: no input file given (use '-' for stdin)\n") unless @ARGV>0;
shift(@ARGV) if ($ARGV[0] eq '-');
my $outfile=$Getopt::Std::opt_o;
my $verbose=$Getopt::Std::opt_V;
my $keepCmts=$Getopt::Std::opt_P;
my $sort_gff=$Getopt::Std::opt_S;
my $Udecode=$Getopt::Std::opt_U;
my $CDSdatafile=$Getopt::Std::opt_y;
my $CDSaddonly=$Getopt::Std::opt_Y;
my $trOnly=$Getopt::Std::opt_F; #only transcript-like records

print STDERR "Command line: ".join(' ',@cmdline)."\n" if $verbose;
die("Error: use only one of -y or -Y!\n") if ($CDSdatafile && $CDSaddonly);
$CDSdatafile=$CDSaddonly if ($CDSaddonly);
my $geneflt=0; #if specific gene filtering was used with -i or -a
my %ignoredFeatures;
@ignoredFeatures{qw(intron region contig scaffold)}=(); #let's ignore these useless features
my %oattrs; #hash with attrs to print
@oattrs{qw(ID transcript_id Parent gene_id gene geneID geneName gene_name)}=();
my %attrflt; # attribute=>value filter
my %idflt;   # hash with IDs to keep
my %atab;    # hash with attribute names whose values will be listed as tab delimited
my %chrmap; #if -m option was provided, maps chrID => new_chrID
my @atab_cols; 
if ($outfile) {
  open(OUTF, '>'.$outfile) || die("Error creating output file $outfile\n");
  select(OUTF);
}
my %assignCDS; # tid =>  [ strand, CDSlo, CDShi, [[cdsegstart, cdsegend],..]]
if ($CDSdatafile) {     #     0    1        2            3
 open(FCDS, $CDSdatafile) || die("Error opening CDS data file $CDSdatafile\n");
 while (<FCDS>) {
   next if m/^#/;
   chomp;
   my ($tid, $strand, $cdsdata)=split(/\t/);
   die ("Error: invalid format encountered for CDS data:$_\n")
     unless ($cdsdata && ($strand eq '-' || $strand eq '+'));
   my ($cds_lo, $cds_hi);
   my @cds;
   if ($cdsdata=~m/^(\d+)\:(\d+)$/) {
      ($cds_lo, $cds_hi)=($1, $2);
   }
   else {
     @cds=map { [(split(/\-/))] } (split(/\,/, $cdsdata));
     #assumed sorted properly!
     ($cds_lo, $cds_hi)=($cds[0]->[0], $cds[-1]->[1]);
   }
   if (exists($assignCDS{$tid})) {
     print STDERR "Warning: multiple CDS (re)assignments given for $tid, only the 1st is used.\n";
     next;
   }
   $assignCDS{$tid}=[$strand, $cds_lo, $cds_hi, [@cds]];
 }
 close(FCDS);
}

# --
my ($fltinvert, $printGTF, $out_track)=
  ($Getopt::Std::opt_v, $Getopt::Std::opt_T, $Getopt::Std::opt_t);
my ($adjGeneSpan, $adjTSpan)=($Getopt::Std::opt_G, $Getopt::Std::opt_M);
my $only_ifCDS=$Getopt::Std::opt_C;
my $discard_exons=($Getopt::Std::opt_c eq 'ds');
$only_ifCDS=1 if $discard_exons;
my ($idfile, $avflt, $featlist, $oattrlist)=
  ($Getopt::Std::opt_i, $Getopt::Std::opt_a, $Getopt::Std::opt_f, $Getopt::Std::opt_k);
die("Sorry, -v option does not work with -f !\n") if $fltinvert && $featlist;
die("Sorry, -v option does not work with -F !\n") if $fltinvert && $trOnly;

my $minIntron=$Getopt::Std::opt_Z ? 5 : 1;
my $keepAll=$Getopt::Std::opt_K || (lc($oattrlist) eq 'a' || lc($oattrlist) eq 'all');
my $discardExonAttrs=$Getopt::Std::opt_E;
die("Error: -E option requires -K !\n") if ($discardExonAttrs && !$keepAll);
my $avflt_feature; #feature targeted by attr=value,.. filter
my $avflt_AND=$Getopt::Std::opt_A; #if $avflt should require a match for ALL given attributes
my ($check_range,        $strict_ovl,         $exon_ovl)=
   ($Getopt::Std::opt_r, $Getopt::Std::opt_R, $Getopt::Std::opt_X);
my $del_range=$Getopt::Std::opt_d;
my $chrmapping=$Getopt::Std::opt_m;
if (($del_range || $chrmapping) && $fltinvert) {
   die("Error: -v option cannot be used with -m or -d options!\n");
}
my ($flt_chr, $flt_strand);
my @flt_intv;
if ($check_range) {
  ($flt_chr, $flt_strand)=parseLocations($check_range, \@flt_intv);
}
my ($del_chr, $del_strand, $del_total);
my @del_intv;
if ($del_range) {
  ($del_chr, $del_strand)=parseLocations($del_range, \@del_intv);
  die("Error: invalid deletion location provided ($del_range)\n") if @del_intv==0;
  $del_total=0;
  foreach my $dseg (@del_intv) {
    $del_total+=$$dseg[1]-$$dseg[0]+1;
  }
}

$oattrlist='' if $keepAll;
my $tab_attrs=$Getopt::Std::opt_l;
if ($tab_attrs) {
  @atab_cols=split(/\,/, $tab_attrs);
  @atab{@atab_cols}=();
  }
my $idfileattr; # attribute to use for ID list filtering instead of ID/transcript_id

if ($idfile) {
  unless (-f $idfile) {
     my ($a,$f)=(split(/\:/,$idfile));
     ($idfile, $idfileattr)=($f,$a) if $f;
     if ($idfileattr eq 'geneID') {
       $idfileattr='.';
       $geneflt=1;
     }
  }
  die("Error: no such id list file: $idfile\n") unless $idfile && -f $idfile;
  my $idf;
  open($idf, $idfile) || die("Error: cannot open $idfile $!\n");
  while (<$idf>) {
    my ($id)=(m/(\S+)/);
    $idflt{$id}=1 if $id;
  }
  close($idf);
}
if ($avflt) {
  my @avl=split(/\;/, $avflt);
  foreach my $avpair (@avl) {
    my ($attr, $value)=split(/\s*=\s*/,$avpair,2);
    if ($attr=~s/^(\w+)\:(\w+)/$2/) {
      $avflt_feature=$1 unless $avflt_feature;
    }
    $value=~s/[" ]+$//;$value=~s/^[" ]+//;
    push(@{$attrflt{$attr}},$value);
    }
  $geneflt=1 if $avflt_feature eq 'gene';
  }
my %featflt; # feature list filter -- if $featlist was given
if ($featlist)  {
 #add to the list of features to be kept
 my @fl=split(/\,/, $featlist);
 @featflt{@fl}=();
 }
if ($oattrlist) {
  #add to the list of attributes to be kept
  my @al=split(/\,/, $oattrlist);
  @oattrs{@al}=();
}

if ($chrmapping) {
 open(CMAP, $chrmapping) || die("Error: cannot open file $chrmapping \n");
 while (<CMAP>) {
   chomp;
   next if length($_)<2 || m/^#/;
   my @m=split(/[\s\,\=]+/);
   next if @m<2;
   $chrmap{$m[0]}=$m[1];
 }
 close(CMAP);
}

##--- gene tracking:
my %genes; #gene ID => [$gffrecs_Data, [$t_ID, ...], $filtered_out)
           #                0               1           2

##--- keeping track of all gene and transcript records :
my %gffrecs; # ID => [ chr, strand, feat_type,  \%attrs, fstart, fend, [@exons], [@cds], track,  geneID, fscore ]
          #             0      1        2           3      4       5       6        7        8      9       10
#my $gffh;
#if ($input_gff eq '-') {
#  open($gffh, "<&=STDIN") || die("Error: couldn't alias STDIN $!\n");
#  }
#  else {
#  open($gffh, $input_gff) ||  die("Error opening file $input_gff $!\n");
#  }
my @gff_IDs; #IDs of each primary records (transcripts and genes) as they are encountered
my $input_GFF3; #set to 1 if input was detected as GFF3
loadGff(\%gffrecs);
$printGTF=1 if (!$printGTF && !$input_GFF3);
if ($sort_gff) {
  my @sorted_recs=sort sortByLoc keys(%gffrecs);
  processGffRecs(\%gffrecs, \@sorted_recs);
}
else {
  processGffRecs(\%gffrecs, \@gff_IDs);
}

# --
if ($outfile) {
 select(STDOUT);
 close(OUTF);
 }

#************ Subroutines **************
sub sortByLoc {
 my $da=$gffrecs{$a};
 my $db=$gffrecs{$b};
 if ($$da[0] eq $$db[0]) {
    return ($$da[4]==$$db[4]) ? $$da[5] <=> $$db[5] : $$da[4] <=> $$db[4] ;
    }
  else { return $$da[0] cmp $$db[0] ; }
}
sub parseLocations {
  my ($s_range, $r_intv)=@_;
  my ($l_chr, $rlst)=split(/\:/,$s_range,2);
  #die("$usage Incorrect format for the interval list!\n") unless $l_chr && $rlst;
  my $l_strand=substr($l_chr,0,1);
  if ($l_strand eq '-' || $l_strand eq '+') {
     substr($l_chr,0,1)='';
  } else {
    $l_strand=undef; 
    my $e=substr($l_chr,-1);
    if ($e eq '-' || $e eq '+') {
        $l_strand=$e;
        chop($l_chr);
    }
    else { #try the suffix
      if ($rlst) {
        my $e=substr($rlst,-1);
        if ($e eq '-' || $e eq '+') {
           $l_strand=$e;
           chop($rlst);
        }
      }
    }
  } #no strand
  $l_strand='' if $l_strand eq '+';
  if ($rlst) {
    my @rdata=map { [split(/[\-\.]+/)] } (split(/[\,\;\s]+/,$rlst));
    foreach my $d (@rdata) {
      ($$d[0], $$d[1])=($$d[1], $$d[0]) if $$d[0]>$$d[1];
    }
    @$r_intv = sort { $a->[0] <=> $b->[0] } @rdata;
  }
  if ($verbose) {
    print STDERR "parsed regions: ${l_strand}$l_chr: ".
      join(', ', (map { $_->[0].'-'.$_->[1] } @$r_intv) )."\n";
  }
  return ($l_chr, $l_strand);
}


sub checkOvlSegs { # $rx must be a ref to list of segments (intervals) SORTED
 my ($a, $b, $rx)=@_;
 return 0 if ($a>$$rx[-1]->[1] || $b<$$rx[0]->[0]); # not overlapping the whole list of segs
 foreach my $x (@$rx) {
   return 1 if ($a<=$$x[1] && $b>=$$x[0]);
   return 0 if $b<$$x[0];
   }
}

sub checkOvlDels {
 # $rseg is a reference to a tuple of coordinates [$a, $b]
 #       $rseg values will be updated according to the global @del_intv deletion data
 # $rx must be a ref to list of segments (intervals) SORTED
 my ($rseg, $rx)=@_; # return 1 if any overlap is found
 return 0 if ($$rseg[1]<$$rx[0]->[0]); # $rseg ends before any deletion
 my $del_acc=0;
 foreach my $x (@$rx) {
   return 1 if ($$rseg[0]<=$$x[1] && $$rseg[1]>=$$x[0]); #overlap with $x
   last if ($$rseg[1]<$$x[0]); #cannot overlap anymore
   $del_acc+=$$x[1]-$$x[0];
 }
 $$rseg[0]-=$del_acc+1;
 $$rseg[1]-=$del_acc+1;
 return 0;
}

sub checkWithinExons {
 my ($a, $b, $rx)=@_; #checks if interval $a-$b is contained in any @$rx interval
 return 0 if ($a>$$rx[-1]->[1] || $b<$$rx[0]->[0]); # not overlapping the whole exon chain
 foreach my $x (@$rx) {
   return 1 if ($a>=$$x[0] && $b<=$$x[1]);
   return 0 if $b<$$x[0];
 }
}


sub cleanupExons {
 my ($er, $rex, $cr, $rcd, $tid)=@_;
 @$rex=@$er;
 @$rcd=@$cr;
 if (@$rcd>0) {
   push(@$rex, @$rcd); #merge CDS segments with UTRs, in case only UTRs were given instead of full exons
   @$rcd=sort { $a->[0] <=> $b->[0] } @$rcd;
 }
 @$rex=sort { $a->[0] <=> $b->[0] } @$rex;
 my $i=0;
 while ($i+1<@$rex) {
   # $$rev[$i] vs $$rex[$i+1]
   my $exdist=$$rex[$i+1]->[0]-$$rex[$i]->[1]; #inter-exon distance
   if ($exdist<=$minIntron) { #intron too small or overlapping exons!
       if ($verbose && $$rex[$i]->[4] eq $$rex[$i+1]->[4]) { #same type of exon
          my $CDstatus=(@$cr>0) ?' (CDS unchanged)' : '';
          $exdist--;
          if ($exdist<0) {
             print STDERR "Warning: merging overlapping ($exdist) exons $$rex[$i]->[0]-$$rex[$i]->[1], ".
               "$$rex[$i+1]->[0]-$$rex[$i+1]->[1] of ${tid}$CDstatus\n";
          } else {
             print STDERR "Warning: merging too close ($exdist) exons $$rex[$i]->[0]-$$rex[$i]->[1], ".
               "$$rex[$i+1]->[0]-$$rex[$i+1]->[1] of ${tid}$CDstatus\n";
          }
       }
       $$rex[$i]->[1]=$$rex[$i+1]->[1] if $$rex[$i+1]->[1]>$$rex[$i]->[1];
       splice(@$rex, $i+1, 1);
   }
   else { ++$i }
 }
 $i=0;
 while ($i+1<@$rcd) { #only adjacent/overlapping CDS and codons will be merged
   # $$rev[$i] vs $$rex[$i+1]
   if ($$rcd[$i+1]->[0]-$$rcd[$i]->[1]<2 &&
       ($$rcd[$i+1]->[4]=~m/codon/i  || $$rcd[$i]->[4]=~m/codon/i ) ) { 
       #adjacent or overlapping CDS with start/stop_codon feature
       if ($verbose) {
         print STDERR "Warning: merging CDS features $$rcd[$i]->[4]($$rcd[$i]->[0]-$$rcd[$i]->[1]) and ".
           "$$rcd[$i+1]->[4]($$rcd[$i+1]->[0]-$$rcd[$i+1]->[1]) of $tid\n";
       }
       $$rcd[$i]->[1]=$$rcd[$i+1]->[1] if $$rcd[$i+1]->[1]>$$rcd[$i]->[1];
       splice(@$rcd, $i+1, 1);
   }
   else { ++$i }
 }
}

#
sub rmTinyIntrons {
 my ($rex)=@_;
 my $i=0;
 while ($i+1<@$rex) {
   # $$rev[$i] vs $$rex[$i+1]
   if ($$rex[$i+1]->[0]-$$rex[$i]->[1]<4) { #intron too small or overlapping exons!
       $$rex[$i]->[1]=$$rex[$i+1]->[1] if $$rex[$i+1]->[1]>$$rex[$i]->[1];
       splice(@$rex, $i+1, 1);
   }
   else { ++$i }
 }
}


sub loadGff {
 my ($recs)=@_; #hash of record IDs to populate (%gffrecs)
 my $isGFF3;
 while (<>) {
   if (m/^\s*#/) {
      push(@gff_IDs, $_) if $keepCmts && !$sort_gff;
      next;
   }
   chomp;
   my ($chr, $track, $f, $fstart, $fend, $fscore, $strand, $frame, $atr)=split(/\t/);
   my $line=$_;
   next unless $fstart>0 && $atr;
   my $reqfeat=exists($featflt{$f});
   next if $featlist && !$reqfeat;
   next if !$reqfeat && exists($ignoredFeatures{lc($f)});
   $track=$out_track if $out_track;
   my $xf;
   my ($isExon, $isCDS);
   if ($f=~m/exon/i || $f=~m/utr/i) {
      $xf='exon';
      $isExon=1;
   }
   if ($f=~m/^cds$/i || $f=~m/codon/i) {
     $xf='CDS';
     $isExon=1; # still an exon-like feature
     $isCDS=1;
   }
   #my $exonFeature=($xf eq 'exon' || $xf eq 'CDS');
   #next if $f eq 'gene' || $f eq 'locus'; # Warning: skipping any 'gene' or 'locus' features, unconditionally
   my $gff3_ID;
   my $gff3_Parent;
   my %attrs;
   ($fstart, $fend)=($fend, $fstart) if $fend<$fstart;
   #$atr=~s/"([^"]+)\;([^"]+)"/"$1.$2"/g; #protect ; in string between quotes?
   my $alstref=[];
   $attrs{'.'}=$alstref;
   my @av=split(/\s*\;\s*/, $atr);
   ($gff3_ID)=($atr=~m/\bID=([^;]+)/);
   ($gff3_Parent)=($atr=~m/\bParent=([^;]+)/);
   my $isGene=($f=~m/gene$/i && $gff3_ID && !$gff3_Parent); ##FIXME - what if a gene *has* a Parent?
   $isGFF3 = ($gff3_ID || $gff3_Parent);
   if ($isGFF3) { # GFF format
      $input_GFF3=1;
      if ($gff3_ID && !$isExon) { #top level feature (e.g. gene, mRNA)
         foreach my $a (@av) {
            #keep attributes
            my ($attr, $value)=split(/\s*=\s*/,$a,2);
            $value=~s/[" ]+$//;$value=~s/^[" ]+//;
            push(@$alstref, $attr) unless $attr eq 'ID';
            $attrs{$attr}=$value;
         }
         die("Error: duplicate feature $gff3_ID\n") if (exists($recs->{$gff3_ID}));
         push(@gff_IDs, $gff3_ID);
         #              0      1      2       3        4      5    6    7    8     9    10
         my $recData=[$chr, $strand, $f, {%attrs}, $fstart, $fend, [], [], $track, 
                                                     ($isGene ? $gff3_ID : $gff3_Parent), $fscore];
         $recs->{$gff3_ID} = $recData;
         if ($isGene) {
           die("Error: gene record already created for $gff3_ID\n") if exists($genes{$gff3_ID});
           $genes{$gff3_ID}=[$recData, [], 0];
         } elsif ($gff3_Parent) { #must be transcript parented by a gene
           my $gData=$genes{$gff3_Parent};
           if ($gData) { #update existing gene entry
             push(@{$gData->[1]}, $gff3_ID);
           }
           else { #create new %genes entry (gene record missing)
             $genes{$gff3_Parent}=[ undef, [$gff3_ID], 0 ];
           }
         }
         next;
      } # parent/top-level feature
   }#GFF3
   else { #GTF
      if ($f eq 'transcript') { # GTF with parent 'transcript' feature
        my $gene_id;
        foreach my $a (@av) {
           my ($attr, $value)=split(/\s+"/,$a,2); #"
           $value=~s/[" ]+$//;
           if ($attr eq 'transcript_id') {
              $attr='ID';
           } else {
             $gene_id=$value if $attr eq 'gene_id';
             push(@$alstref, $attr);
           }
           $attrs{$attr}=$value;
        }
        my $gffID=$attrs{'ID'};
        die("Error: cannot find transcript_id for GTF 'transcript' line:\n$line\n") unless $gffID;
        die("Error: duplicate feature $gffID\n") if (exists($recs->{$gffID}));
        push(@gff_IDs, $gffID);
        $recs->{$gffID} = [$chr, $strand, $f, {%attrs}, $fstart, $fend, [], [], $track, $gene_id, $fscore ];
        if ($gene_id) {
           my $gData=$genes{$gene_id};
           if ($gData) { #update existing %genes entry
             push(@{$gData->[1]}, $gffID);
           }
           else { #create new %genes entry
            $genes{$gene_id} = [ undef, [$gffID], 0 ];
           }
        }
        next;
      } # parent 'transcript' feature in GTF
   } #GTF
   # ---------- only exon/CDS features from here on ----
   next unless $isExon;
   my $recID;
   if ($isGFF3) {
      $recID=$gff3_Parent;
   }
   elsif ($atr=~m/transcript_id[= ]+(['"\:\w\.\|\-]+)/) {
     $recID=$1;
     $recID=~tr/"//d; #"
   }
   else {
     die("Error: cannot parse parent ID from input line:\n$line\n");
   }
   my $ld = $recs->{$recID};
   if ($ld) { #existing entry
     my $i=($xf eq 'CDS') ? 7 : 6;
     my ($lstart, $lend)=($$ld[4], $$ld[5]);
     if ($adjTSpan) {
       if ($fstart<$lstart) {
          print STDERR "Warning: adjusting $recID start $$ld[4] to $fstart due to exon $fstart-$fend\n"
             if $verbose;
          $$ld[4]=$fstart;
       }
       if ($fend>$lend) {
          print STDERR "Warning: adjusting $recID end $$ld[5] to $fend due to exon $fstart-$fend\n"
             if $verbose;
          $$ld[5]=$fend;
       }
     }
     my $exattrs='';
     #if ($isGFF3 && !$discardExonAttrs) {
     if ($keepAll && !$discardExonAttrs) {
       $exattrs=$atr;
       if ($isGFF3) { $exattrs=~s/\bParent=[^;]+;?//; }
       else { 
         $exattrs=~s/\btranscript_id\s+[^;]+;?//;
         $exattrs=~s/\bgene_id\s+[^;]+;?//;
       }
     }
     # --- exon feature storage format:  start, end, score, CDSphase, feature_name, GFF_attributes
     push(@{$$ld[$i]}, [$fstart, $fend, $fscore, $frame, $f, $exattrs]);
     #                       0      1       2       3     4   5
   }
   else { # first time seeing this ID (shouldn't really happen for GFF3)
     # get the attributes from this first exon line, transfer to the parent
     if ($gff3_Parent) { #has GFF3 Parent - this should NOT happen usually
       print STDERR "Warning: exon feature found before/without parent $gff3_Parent!\n$line\n";
       foreach my $a (@av) {
          my ($attr, $value)=split(/\s*=\s*/,$a,2);
          $attr='ID' if $attr eq 'Parent';
          $value=~s/[" ]+$//;$value=~s/^[" ]+//;
          push(@$alstref, $attr) unless $attr eq 'ID';
          $attrs{$attr}=$value;
       }
     }
     else { # GTF input
       die("Error: found exon/CDS entry without parent!\n$line\n") if ($isGFF3);
       foreach my $a (@av) {
           my ($attr, $value)=split(/\s+"/,$a,2); #"
           $value=~s/[" ]+$//;
           if ($attr eq 'transcript_id') {
              $attr='ID';
           } else {
              push(@$alstref, $attr);
           }
           $attrs{$attr}=$value;
       }
     }
     $recs->{$recID} = ($f eq 'CDS') ? 
           [$chr, $strand, 'transcript', {%attrs}, $fstart, $fend,          [],      [[$fstart, $fend, $fscore, $frame, $f]], $track, '', '.' ] :
           [$chr, $strand, 'transcript', {%attrs}, $fstart, $fend, [[$fstart, $fend, $fscore, $frame, $f]], [],               $track, $f, '.' ] ;
         #   0       1      2     3        4       5       6(exons)                          7 (CDS)                           8       9   10
   }
 }
}

sub assignCDS {
 my ($tid, $rstrand, $exr, $cdr, $tcds)=@_;
 my ($cstrand, $cds_lo, $cds_hi, $cdsegs)=@$tcds;
 my ($ex_lo, $ex_hi)=($$exr[0]->[0], $$exr[-1]->[1]);
 my @info;
 my $changeExisting=0;
 if ($$rstrand ne $cstrand) {
   if ($CDSaddonly && scalar(@$cdr)>0) {
      $changeExisting=1;
      push(@info, 'strand would have changed to '.$cstrand);
   } else {
      $$rstrand=$cstrand;
      push(@info, 'strand changed to '.$cstrand);
   }
 }
 #check if the intervals are compatible
 if ($cds_lo<$ex_lo || $cds_lo>$ex_hi) {
   print STDERR "Error: new CDS lower boundary ($cds_lo) outside the region of transcript $tid ($ex_lo-$ex_hi)!\n";
 }
 if ($cds_hi<$ex_lo || $cds_hi>$ex_hi) {
   print STDERR "Error: new CDS higher boundary ($cds_hi) outside the region of transcript $tid ($ex_lo-$ex_hi)!\n";
 }
 if (@$cdsegs==0) { #rebuild cdsegs from cds_lo:cds_hi
  my ($cdstarted, $cdended);
  foreach my $e (@$exr) {
     my ($cdstart, $cdsend)= ( $$e[0], $$e[1] );
     if (!$cdstarted && $cds_lo>=$$e[0] && $cds_lo<=$$e[1]) {
        $cdstart=$cds_lo;
        $cdstarted=1;
     }
     if ($cdstarted && $cds_hi>=$$e[0] && $cds_hi<=$$e[1]) {
        $cdsend=$cds_hi;
        $cdended=1;
     }
     push(@$cdsegs, [$cdstart, $cdsend]) if $cdstarted;
     last if $cdended;
  }
  die("Error mapping new CDS boundaries ($cds_lo:$cds_hi) to $tid exons!\n") unless @$cdsegs>0;
 }
 #add phase to CDS (assuming starts with 0)
 my $pcds=$cdsegs;
 my @revcds;
 if ($cstrand eq '-') {
   @revcds=reverse(@$cdsegs);
   $pcds=\@revcds;
 }
 my ($ph, $aclen)=(0,0);
 foreach my $cs (@$pcds) {
   if ($aclen) { $ph = ((3-$aclen) % 3)%3; }
   $aclen+=$$cs[1]-$$cs[0]+1;
   die("Error: unexpected CDS segment data for $tid CDS assignment!\n") if (@$cs!=2);
   push(@$cs, '.');
   push(@$cs, $ph);
   push(@$cs, 'CDS');
 }
 if (scalar(@$cdr)==0) {
   push(@info, "CDS added: $cds_lo:$cds_hi");
   @$cdr=@$cdsegs;
 }
 else { # re-assigned
   my $changed='preserved';
   my $ch;
   if (scalar(@$cdr) == scalar(@$cdsegs)) {
      for (my $i=0;$i<@$cdr;$i++) {
        if ($$cdr[$i]->[0]!=$$cdsegs[$i]->[0] || 
            $$cdr[$i]->[1]!=$$cdsegs[$i]->[1] ||
            $$cdr[$i]->[3] ne $$cdsegs[$i]->[3]) {
            $ch=1;
            last;
        }
      }
   } else { $ch=1;}
   if ($ch) {
     if ($CDSaddonly) {
       $changed='would have changed';
     } else {
       @$cdr=@$cdsegs;
       $changed='changed';
     }
   }
   push(@info, "CDS $changed: $cds_lo:$cds_hi");
 }
 if ($verbose && @info) {
   print STDERR "INFO: CDS assign for $tid: ".join('; ',@info)."\n";
 }
}

sub processGffRecs {
 #return if keys(%recs)==0;
 my ($recs, $rlist)=@_;
 my @recs_keys;
 unless ($rlist) {
   @recs_keys=keys(%$recs);
   $rlist=\@recs_keys;
 }
 my $lastchr; #to detect chr change
 my $dshift=0;
 foreach my $recid (@$rlist) {
   if ($keepCmts && $recid=~m/^\s*#/) {
     print $recid; #comment lines are printed as is
     next;
   }
   my $td=$$recs{$recid};
   die("Error: cannot find GFF record for $recid\n") unless $td;
   #     0       1       2        3        4      5       6    7      8       9      10    
   my ($chr, $strand, $feature, $attrs, $fstart, $fend,  $er, $cr,  $track, $geneID, $fscore) = @$td;
   my $newchr=($chr ne $lastchr);
   if ($newchr) {
      $dshift=0;
      $lastchr=$chr;
   }
   #next if ($rej && !$fltinvert);
   #next if ($fltinvert && $featlist && !$rej);
   my $isGene=($geneID eq $recid);
   my $CDSonly=0; # set to 1 if only CDS segments were given
   my $hasCDS=0;
   #some records might lack exons, but have only CDS segments (e.g. mitochondrial genes)
   if (@$er<1 && @$cr>0) { #no exon entries, but CDS
     #@ex = sort { $a->[0] <=> $b->[0] } @$cr;
     #@cds=@ex;
     $CDSonly=1;
     $hasCDS=1;
   } else { #exons declared
     #@ex = sort { $a->[0] <=> $b->[0] } @$er;
     if (@$cr>0) { # sort cds segments too
       #@cds= sort { $a->[0] <=> $b->[0] } @$cr;
       $hasCDS=1;
     }
   }
   my @ex; #refined exon segments (in case only UTRs are given, or non-CDS exon fragments)
   my @cds; #refined CDS segments (in case start/stop_codons are given)
   if ($discard_exons) {
     @cds=sort { $a->[0] <=> $b->[0] } @$cr;
     $CDSonly=1;
     #-- also silently adjust transcript boundaries to just the CDS region
     ($fstart, $fend)=($cds[0]->[0], $cds[-1]->[1]);
   } else {
     cleanupExons($er, \@ex, $cr, \@cds, $recid); #check for merging exon/UTR/CDS/start_codon/stop_codon into exon/CDS segments
   }
   #---- for transcripts, check for new CDS/strand assignment 
   if ($CDSdatafile && @ex>0) { # $discard_exons is incompatible with -y option
      my $tcds=$assignCDS{$recid};
      assignCDS($recid, \$strand, \@ex, \@cds, $tcds) #modifies $strand and @cds as needed!
         if ($tcds);
   }
   if (scalar(@cds)>0 && $attrs->{'TYPE'} eq 'non_coding') {
       #make sure that TYPE is changed from "non_coding" to "protein_coding_uncertain"
       $attrs->{'TYPE'}='protein_coding_uncertain';
       print STDERR "INFO: $recid TYPE changed to 'protein_coding_uncertain'\n" if $verbose;
   }
   # --------------
   # get the more accurate version of the start-end coords for the feature
   my $covlen=0;
   #my $gffid=$recid;
   #substr($gffid, 0, length($chr)+1)='';
   die("Error: GFF ID ($recid) not matching attrs\{ID\}(".$attrs->{'ID'}.")!\n")
       unless ($recid eq $attrs->{'ID'});
       
   ##---check/fix gene boundaries first!
   if ($isGene) {
     my $gdata=$genes{$recid};
     if ($gdata) { #should be there!
        my ($min, $max);
        foreach my $tid (@{$gdata->[1]}){
          my $tdata=$$recs{$tid};
          if ($tdata) {
             if ($tdata->[0] eq $chr) {
                $min=$tdata->[4] if $tdata->[4]<$min || !$min;
                $max=$tdata->[5] if $tdata->[5]>$max;
             }
             else {
               die("Error: gene $recid has different chromosome ($chr) than its transcript $tid ($tdata->[0])!\n");
             }
          }
          else {
            die("Error: could not retrieve transcript data for $tid of gene $recid!\n")
              unless $tdata;
          }
        }#for each transcript of this gene
        if ($adjGeneSpan && $min && $max && ($min!=$fstart || $max!=$fend)) {
          print STDERR "Warning: gene $recid original span ($fstart-$fend) adjusted to ($min-$max)\n"
             if $verbose;
          ($fstart, $fend)=($min, $max);
        }
     }
     else {
       print STDERR "Warning: no %genes entry found for $recid !\n";
     }
   } else { # not a gene - so likely a transcript
     #should be skipped if parent gene was already filtered out
     my $gdata=$genes{$geneID};
     if ($geneflt && $gdata && $gdata->[2]==1) { #gene was specifically filtered out!
       #$doprint=0;
       #that gene filter has already been inverted!
       next;
     }
   }
   next if ($trOnly && @ex==0 && @cds==0);
   my $doprint=1;
   #check all the filters
   $doprint=0 if ($only_ifCDS && $hasCDS==0);
   if ($doprint && $idfile) {
     if ($idfileattr) {
        $doprint=0 unless exists($idflt{$attrs->{$idfileattr}});
      }
      else {
        $doprint=0 unless exists($idflt{$recid});
      }
   }
   my $check_avflt=$avflt && ((!$avflt_feature && !$isGene) || ($avflt_feature eq $feature));
   if ($doprint && $check_avflt) {
      my $avfound=0;
      if ($avflt_AND) {
        #all attributes must be present and match
        $avfound=1;
        foreach my $a (keys(%attrflt)) {
          my $v=$attrs->{$a};
          my $fvs=$attrflt{$a};
          if (!$v || !$fvs) { $avfound=0; last; }
          foreach my $fv (@$fvs) {
            if ($fv ne $v) {
              $avfound=0;
              last;
            }
          }
          last if $avfound==0;
        }
      } else {
        foreach my $a (keys(%attrflt)) {
          foreach my $fv (@{$attrflt{$a}}) {
            if ($fv eq $attrs->{$a}) {
              $avfound=1;
              last;
            }
            last if $avfound;
          }
        }
      }
      $doprint=0 if !$avfound;
   }
  
   if ($doprint && $flt_chr && $flt_chr ne $chr) {
     $doprint=0;
   }
   if ($doprint) {
     if ($flt_strand && $flt_strand ne $strand) {
       $doprint=0;
     }
   }
   if ($doprint && @flt_intv>0) {
    my $ovlmatch=0;
    if ($exon_ovl) { #t span overlap any range intervals
       for my $ed (@ex) {
         if (checkOvlSegs($$ed[0], $$ed[1], \@flt_intv)) {
            $ovlmatch=1;
            last;
            }
         }
    } elsif ($strict_ovl) {
       $ovlmatch=checkOvlWithin($fstart, $fend, \@flt_intv);
    } else {
       $ovlmatch=checkOvlSegs($fstart, $fend, \@flt_intv);
    }
    $doprint=$ovlmatch;
  }
  #inverting the filter?
  $doprint = !$doprint if $fltinvert;
  if (!$doprint) {
     if ($isGene && $geneflt) { #specific gene filtering
       my $gdata=$genes{$recid};
       $gdata->[2]=1 if $gdata;
     }
     next;
  }
  ## --check for chr sequence deletion
  if ($del_chr && $del_chr eq $chr) {
     my $fspan=[$fstart, $fend];
     my $fovldel=checkOvlDels($fspan, \@del_intv);
     if ($fovldel && $isGene) {
        print STDERR "INFO: gene $recid discarded due to overlapping deleted region.\n"
          if $verbose;
        my $gdata=$genes{$recid};
        $gdata->[2]=1 if $gdata;
        next;
     }
     my $exovl; #set if exon overlap detected
     for my $ed (@ex) {
        $exovl=checkOvlDels($ed, \@del_intv); 
        last if $exovl;
     }
     if ($exovl) {
        print STDERR "INFO: transcript $recid discarded due to overlapping deleted region.\n"
          if $verbose;
        next;
     }
     elsif (@cds>0) { #have to adjust CDS coordinates too
       for my $cd (@cds) {
          if (checkOvlDels($cd, \@del_intv)) { 
            die("Error ($recid): CDS are overlapping deleted regions, even though exons weren't?!\n");
          }
       }
     }
     if ($fovldel && @ex>0) {
       #adjust transcript coordinates
       ($fstart, $fend)=($ex[0]->[0], $ex[-1]->[1]);
     }
  }
  #filter passed, print output
  #if ($delTinyIntrons) {
  #  rmTinyIntrons(\@ex) if @ex>1;
  #  #-- do NOT do it for CDS - because of "ribosomal slippage exception" (programmed frameshift)
  #  #rmTinyIntrons(\@cds) if @cds>1;
  #}
  
  if ($tab_attrs) {
     my @od;
     foreach my $a (@atab_cols) {
       if (uc($a) eq 'ID') {
          push(@od, $recid);
          next;
       }
       if (substr($a,0, 1) eq '@') {
         my $f=substr($a,1);
         if ($f eq 'chr') {
           push(@od, $chr);
         }
         elsif ($f eq 'start') {
           push(@od, $fstart);
         }
         elsif ($f eq 'end') {
           push(@od, $fend);
         }
         elsif ($f eq 'strand') {
           push(@od, $strand);
         }
         elsif ($f eq 'numexons') {
           push(@od, scalar(@ex));
         }
         elsif ($f eq 'exons') {
          push(@od, join(',', (map { "$$_[0]-$$_[1]" } @ex)));
         }
         elsif ($f eq 'cds') {
          push(@od, @cds>0 ? join(',', (map { "$$_[0]-$$_[1]" } @cds)) : '.');
         }
         next;
       }
       push(@od, $attrs->{$a} || '.');
     }
     print join("\t",@od)."\n";
     next;
  }
  #chromosome mapping (renaming) requested?
  if ($chrmapping) {
    my $cnew=$chrmap{$chr};
    $chr=$cnew if ($cnew);
  }
  
  my $tid=delete($attrs->{'ID'});
  my $tattrs;
  if ($printGTF) {
     my $pattrs;
     #do not print gene features or features without exons/CDS!
     next unless (@ex>0 || @cds>0);
     my $gene_id; #for GTF printing
     $gene_id=delete($attrs->{'gene_id'});
     if (!$gene_id) {
       my @gattrs=grep { /^gene_?id/i } @{$attrs->{'.'}};
       $gene_id=delete($attrs->{$gattrs[0]}) if @gattrs>0
     }
     if (!$gene_id) {
       my @gattrs=grep { /^gene$/i } @{$attrs->{'.'}};
       @gattrs=grep { /^gene/i } @{$attrs->{'.'}} if (@gattrs==0);
       $gene_id=delete($attrs->{$gattrs[0]}) if @gattrs>0
     }
     $pattrs='transcript_id "'.$tid.'";';
     $pattrs.=' gene_id "'.$gene_id.'";' if $gene_id;
     $tattrs=$pattrs;
     if ($keepAll) {
        foreach my $attr (@{$attrs->{'.'}}) {
           my $val=$attrs->{$attr};
           if ($Udecode) {
             $val=gff3_decode($val);
             $val=gff3_fixspecial($val, 1);
           }
           $pattrs.=' '.$attr.' "'.$val.'";' if $val;
        }
     }
     else { # only a subset of attributes will be shown
        foreach my $attr (@{$attrs->{'.'}}) {
           next unless exists($oattrs{$attr});
           my $val=$attrs->{$attr};
           if ($Udecode) {
             $val=gff3_decode($val);
             $val=gff3_fixspecial($val, 1);
           }
           $pattrs.=' '.$attr.' "'.$val.'";' if $val;
        }
     }
    print join("\t",$chr, $track, 'transcript', $fstart, $fend, $fscore, $strand, '.', $pattrs)."\n";
  } else { #print GFF3
     my $pattrs="ID=$tid";
     #$pattrs.='gene_name='.$gene_name.';' if $gene_name;
     #$pattrs.='gene='.$gene.';' if $gene;
     #$pattrs.='locus='.$locus.';' if $locus;
     if ($keepAll) {
        foreach my $attr (@{$attrs->{'.'}}) {
           my $val=$attrs->{$attr};
           if ($Udecode) {
             $val=gff3_decode($val);
             $val=gff3_fixspecial($val);
           }
           $pattrs.=";$attr=$val" if $val;
           }
     }
     else { # only a subset of attributes will be shown
        foreach my $attr (@{$attrs->{'.'}}) {
           next unless exists($oattrs{$attr});
           my $val=$attrs->{$attr};
           if ($Udecode) {
             $val=gff3_decode($val);
             $val=gff3_fixspecial($val);
           }
           $pattrs.=";$attr=$val" if $val;
        }
     }
     print join("\t",$chr, $track, $feature, $fstart, $fend, $fscore, $strand, '.', $pattrs)."\n";
     $tattrs='Parent='.$tid;
  }
  { local $/=';'; chomp($tattrs); }
  if ($CDSonly==0) { #write exons only when they're also found in the input
        foreach my $ed (@ex) {
            my $xattrs=$tattrs;
            $xattrs.=';'.$$ed[5] if $$ed[5];
            print join("\t",$chr, $track, 'exon', $$ed[0], $$ed[1], $$ed[2], $strand, $$ed[3], $xattrs)."\n";
        }
  }
  foreach my $cd (@cds) {
        my $xattrs=$tattrs;
        $xattrs.=';'.$$cd[5] if $$cd[5];
        print join("\t",$chr, $track, 'CDS', $$cd[0], $$cd[1], $$cd[2], $strand, $$cd[3], $xattrs)."\n";
  }
 } #for each stored transcript
}

sub gff3_encode {
 my ($v) = @_;
 $v =~ s/([^A-Za-z0-9])/sprintf("%%%2.2X", ord($1))/ge;
 return $v;
}

sub gff3_fixspecial {
 my ($v, $GTF) = @_;
 $v=~tr/\x00-\x1F\x7f/ /;
 $v=~tr/;,&/| _/;
 $v=~s/\s*=\s*/:/g;
 $v=~s/\s*\%/ prc./g;
 $v=~tr/"/'/ if $GTF; #"protect for GTF
 return $v;
}

sub gff3_decode {
 #actually decodes any % encoded characters
 my ($v) = @_;
 #$v =~ s/\+/ /g; #url decoding would also need this
 $v =~ s/%(..)/pack('c',hex($1))/ge;
 return $v;
}
