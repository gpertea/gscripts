#!/usr/bin/perl
use strict;
use Getopt::Std;
use FindBin;use lib $FindBin::Bin;

my $usage = q/Usage:
 gffmanip [-v] [-o outrecords.txt] [-r<regata> [-R][-E]] [-t <track>] \
  [-f <feature1>[,..]] [-i [<attr>:]<tids.lst>] [-a <attr>=<value>[,..]] \
  [-k <attr1>[,..]] [-l <attr1>[,..]] [-m <IDchange.tab>] [-d <regdata>] \
    <gff\/gtf-input>

Filtering options:
 -C output only those transcripts having CDS features (protein Coding)
 -f output only the specified GFF features, given as a comma-delimited
    list of strings (e.g. -f 'mRNA,exon,CDS')
 -r show only transcripts overlapping any of the region intervals given in 
    <regdata> which has the format:
       [<strand>]<chr>[:<start>-<end>[,<start2>-<end2>,...]]
 -E for -r option, only print records whose exon\/CDS segments overlap the given
    interval(s) (i.e. intron-only overlaps are not considered)
 -R for -r option, only print transcripts fully contained in any of the given 
    range interval(s)
 -i only shows transcripts (or genes) whose IDs match any of the entries in the
    given file <ids.lst>; another attribute instead of ID can be used for 
    matching the list values if given as a <attr>: prefix to the file path
 -a only shows transcripts which have the <attr> attribute with the value 
    <value>; multiple attribute\/value pairs can be given (comma delimited)
    and a record is printed if there is at least one attribute match (OR list)
 -A for the -a option, when multiple <attr>=<value> conditions are given 
    (comma delimited), all of them have to be present and match (AND list)
 -v invert the filters (like grep's -v): print records that do NOT match any of
    the above transcript filtering options

Location modification options:
 -m replace contig\/chromosome IDs with different IDs, as specified in the given
    ID mapping table (a two column table mapping the old ID to the new ID)
 -d contig\/chromosome region(s) deletion: discard the transcripts overlapping
    the given genomic region(s), shifting the coordinates of all the 
    features downstream from a deleted region
 
Output options:
 -K keep all attributes; by default only the core GFF\/GTF attributes are
    shown (transcript_id, gene_id, gene_name, ID, Parent, Name, gene_name)
 -k keep only the specified non-core attributes in the output records
    (expects a comma delimited list of attribute names)
 -T print GTF format (default is GFF3)
 -l instead of GTF\/GFF, output a tab delimited table with transcript ID 
    in the first column and the value of all specified attribute(s) for each
    transcript in the other columns
 -t replace the string in the 2nd column with the given <track> text
/;
umask 0002;
getopts('vCERAKTo:f:t:i:a:k:l:m:d:') || die($usage."\n");
die("${usage}Error: no input file given (use '-' for stdin)\n") unless @ARGV>0;
shift(@ARGV) if ($ARGV[0] eq '-');
my $outfile=$Getopt::Std::opt_o;
my %ignoredFeatures;
@ignoredFeatures{qw(intron cds_start cds_stop start_codon stop_codon start stop cdsstart cdsstop)}=();
my %oattrs; #hash with attrs to print
@oattrs{qw(ID transcript_id Parent gene_id gene geneID geneName gene_name)}=();
my %attrflt; # attribute=>value filter
my %idflt;   # hash with IDs to keep
my %atab;    # hash with attribute names whose values will be listed as tab delimited
my %chrmap; #if -m option was provided, maps chrID => new_chrID
my @atab_cols; 
if ($outfile) {
  open(OUTF, '>'.$outfile) || die("Error creating output file $outfile\n");
  select(OUTF);
}
# --
my ($fltinvert, $printGTF, $out_track)=
  ($Getopt::Std::opt_v, $Getopt::Std::opt_T, $Getopt::Std::opt_t);
my $only_ifCDS=$Getopt::Std::opt_C;
my ($idfile, $avflt, $featlist, $oattrlist)=
  ($Getopt::Std::opt_i, $Getopt::Std::opt_a, $Getopt::Std::opt_f, $Getopt::Std::opt_k);
my $keepAll=$Getopt::Std::opt_K || (lc($oattrlist) eq 'a' || lc($oattrlist) eq 'all');
my $avflt_all=$Getopt::Std::opt_A; #if $avflt should require a match for ALL given attributes
my ($check_range, $strict_ovl, $exon_ovl)=
   ($Getopt::Std::opt_r, $Getopt::Std::opt_R, $Getopt::Std::opt_E);
my $del_range=$Getopt::Std::opt_d;
my $chrmapping=$Getopt::Std::opt_m;
if (($del_range || $chrmapping) && $fltinvert) {
   die("Error: -v option cannot be used with -m or -d options!\n");
}
my ($flt_chr, $flt_strand);
my @flt_intv;
if ($check_range) {
  ($flt_chr, $flt_strand)=parseLocations($check_range, \@flt_intv);
}
#my $range=$flt_chr.':'.$ck_rex[0]->[0].'-'.$ex[-1]->[1];
my ($del_chr, $del_strand);
my @del_intv;
if ($del_range) {
  ($del_chr, $del_strand)=parseLocations($del_range, \@del_intv);
  die("Error: invalid deletion location provided ($del_range)\n") if @del_intv==0;
}

$oattrlist='' if $keepAll;
my $tab_attrs=$Getopt::Std::opt_l;
if ($tab_attrs) {
  @atab_cols=split(/\,/, $tab_attrs);
  @atab{@atab_cols}=();
  }
my $idfileattr; # attribute to use for ID list filtering instead of ID/transcript_id
if ($idfile) {
  unless (-f $idfile) {
     my ($a,$f)=(split(/\:/,$idfile));
     ($idfile, $idfileattr)=($f,$a) if $f;
     }
  my $idf;
  #if ($idfile eq '-') {
  #  open($idf, "<&=STDIN") || die("Error: couldn't alias STDIN. $!\n");
  #} else {
    open($idf, $idfile) || die("Error: cannot open $idfile $!\n");
  #}
  while (<$idf>) {
    my ($id)=(m/(\S+)/);
    $idflt{$id}=1 if $id;
    }
  close($idf);
  }
if ($avflt) {
  my @avl=split(/\,/, $avflt); 
  foreach my $avpair (@avl) {
    my ($attr, $value)=split(/\s*=\s*/,$avpair,2);
    $value=~s/[" ]+$//;$value=~s/^[" ]+//;
    $attrflt{$attr}=$value;
    }
  }
my %featflt; # feature list filter -- if $featlist was given
if ($featlist)  {
 #add to the list of features to be kept
 my @fl=split(/\,/, $featlist);
 @featflt{@fl}=();
 }
if ($oattrlist) {
  #add to the list of attributes to be kept
  my @al=split(/\,/, $oattrlist);
  @oattrs{@al}=();
}
# ---- 
my %gffrecs; # recID =>  [ chr, strand, feat_type,  \%attrs, fstart, fend, [@exons], [@cds], isgff3, rejected, track, subfeat, fscore ]
          #                0      1        2           3      4       5       6        7        8        9     10   ,   11,     12
          # recID has the prefix '<chr>|' which should be removed before output
#my $gffh;
#if ($input_gff eq '-') {
#  open($gffh, "<&=STDIN") || die("Error: couldn't alias STDIN $!\n");
#  }
#  else {
#  open($gffh, $input_gff) ||  die("Error opening file $input_gff $!\n");
#  }

loadGff(\%gffrecs);
my @sorted_recs=sort sortByLoc keys(%gffrecs);
processGffRecs(\%gffrecs, \@sorted_recs);

# --
if ($outfile) {
 select(STDOUT);
 close(OUTF);
 }

#************ Subroutines **************
sub sortByLoc {
 my $da=$gffrecs{$a};
 my $db=$gffrecs{$b};
 if ($$da[0] eq $$db[0]) {
    return ($$da[4]==$$db[4]) ? $$da[5] <=> $$db[5] : $$da[4] <=> $$db[4] ;
    }
  else { return $$da[0] cmp $$db[0] ; }
}
sub parseLocations {
  my ($s_range, $r_intv)=@_;
  my ($l_chr, $rlst)=split(/\:/,$s_range,2);
  #die("$usage Incorrect format for the interval list!\n") unless $l_chr && $rlst;
  my $l_strand=substr($l_chr,0,1);
  if ($l_strand eq '-' || $l_strand eq '+') {
     substr($l_chr,0,1)='';
  } else {
    $l_strand=undef; 
    my $e=substr($l_chr,-1);
    if ($e eq '-' || $e eq '+') {
        $l_strand=$e;
        chop($l_chr);
    }
    else { #try the suffix
      if ($rlst) {
        my $e=substr($rlst,-1);
        if ($e eq '-' || $e eq '+') {
           $l_strand=$e;
           chop($rlst);
        }
      }
    }
  } #no strand
  $l_strand='' if $l_strand eq '+';
  if ($rlst) {
    my @rdata=map { [split(/[\-\.]+/)] } (split(/[\,\;\s]+/,$rlst));
    foreach my $d (@rdata) {
      ($$d[0], $$d[1])=($$d[1], $$d[0]) if $$d[0]>$$d[1];
    }
    @$r_intv = sort { $a->[0] <=> $b->[0] } @rdata;
  }
  return ($l_chr, $l_strand);
}


sub checkOvlExons {
 my ($a, $b, $rx)=@_;
 return 0 if ($a>$$rx[-1]->[1] || $b<$$rx[0]->[0]); # not overlapping the whole exon chain
 foreach my $x (@$rx) {
   return 1 if ($a<=$$x[1] && $b>=$$x[0]);
   return 0 if $b<$$x[0];
   }
}

sub checkWithinExons {
 my ($a, $b, $rx)=@_; #checks if interval $a-$b is contained in any @$rx interval
 return 0 if ($a>$$rx[-1]->[1] || $b<$$rx[0]->[0]); # not overlapping the whole exon chain
 foreach my $x (@$rx) {
   return 1 if ($a>=$$x[0] && $b<=$$x[1]);
   return 0 if $b<$$x[0];
   }
}


sub loadGff {
 my ($recs)=@_;
 while (<>) {
   next if m/^\s*#/;
   chomp;
   my ($chr, $track, $f, $fstart, $fend, $fscore, $strand, $frame, $lnum)=split(/\t/);
   next unless $fstart>1 && $lnum;
   $track=$out_track if $out_track;
   next if exists($ignoredFeatures{lc($f)});
   $f='exon' if $f=~m/exon/i;
   $f='CDS' if $f=~m/^cds$/i;
   my $rejected;
   $rejected=1 if ($featlist && not exists($featflt{$f}));
   #next if $f eq 'gene' || $f eq 'locus'; # Warning: skipping any 'gene' or 'locus' features, unconditionally
   my $gff3_ID;
   my $gff3_Parent;
   my ($gname,$tdescr);
   my %attrs;
   ($fstart, $fend)=($fend, $fstart) if $fend<$fstart;
   #$lnum=~s/"([^"]+)\;([^"]+)"/"$1.$2"/g; #protect ; within text between quotes
   my @av=split(/\s*\;\s*/,$lnum);
   ($gff3_ID)=($lnum=~m/\bID=([^;]+)/);
   ($gff3_Parent)=($lnum=~m/\bParent=([^;]+)/);
   my $isGFF3 = ($gff3_ID || $gff3_Parent);
   if ($isGFF3) { # GFF format
      $gff3_ID=~tr/"//d; #"
      $gff3_Parent=~tr/"//d; #"
      $gff3_Parent='' if ($f =~m/RNA/); # we really don't care about transcript's parent 
      if ($gff3_ID && !$gff3_Parent) { #top level feature
         foreach my $a (@av) {
            my ($attr, $value)=split(/\s*=\s*/,$a,2);
            $value=~s/[" ]+$//;$value=~s/^[" ]+//;
            $attrs{$attr}=$value;
            }
         if ($f=~m/RNA/i || $f=~/gene/) {
           # try to parse the description, if any
           
           if ($lnum=~m/\b(?:descr|tophit|info|product)\s*=\s*"?([^;"]+)/i) {
             $tdescr=$1;
             }
            elsif ($lnum=~m/Name\s*=\s*"?([^;"]+)/) {
             $tdescr=$1;
             }
           if ($lnum=~m/\bgene_name[\s=]+"?([^;"]+)/i) {
             $gname=$1;
             }
            elsif ($lnum=~m/Name\s*=\s*"?([^;"]+)/) {
             $gname=$1;
             }
           $tdescr='' if ($tdescr eq $gname);
           $gname='' if $gname eq $gff3_ID;
           }
         die("Error: duplicate feature $gff3_ID on $chr\n") if (exists($recs->{"$chr|$gff3_ID"}));
         my $recID="$chr|$gff3_ID";
         $recs->{$recID} = [$chr, $strand, $f, {%attrs}, $fstart, $fend, [], [], $isGFF3, $rejected, $track, '', $fscore];
         next;
         } # parent/top-level feature
      } #GFF
     else { #GTF format
      if ($f eq 'transcript') { # GTF with parent 'transcript' feature
        foreach my $a (@av) {
           my ($attr, $value)=split(/\s+"/,$a,2); #"
           $value=~s/[" ]+$//;
           if ($attr eq 'transcript_id') {
                     $attr='ID';
                     }
                  elsif ($attr eq 'gene_id') {
                     $attr='Name';
                     }
           $attrs{$attr}=$value;
           }
        my $recID=$attrs{'ID'};
        die("Error: cannot find transcript_id for GTF 'transcript' line:\n$_\n") unless $recID;
        die("Error: duplicate feature $recID on $chr\n") if (exists($recs->{"$chr|$recID"}));
        $recID=$chr.'|'.$recID;
        $recs->{$recID} = [$chr, $strand, $f, {%attrs}, $fstart, $fend, [], [], $isGFF3, $rejected, $track, '', $fscore ];
        next;
        } # parent 'transcript' feature in GTF
      }
   # -------------- exon/CDS line here:
   next if ($featlist && !exists($featflt{$f}));
   my $recID;
   ($gname, $tdescr)=();
   if ($isGFF3) {
      $recID=$gff3_Parent;
      }
    elsif ($lnum=~m/transcript_id[= ]+(['"\:\w\.\|\-]+)/) {
     $recID=$1;
     $recID=~tr/"//d; #"
     }
    elsif ($track=~/^jigsaw/ && $lnum=~m/^\d+$/) {
     $recID=$chr.'.jsm.'.$lnum;
     $gff3_Parent=$recID;
     $isGFF3=1;
     $f='CDS';
     }
    else {
     die("Error: cannot parse locus/transcript name from input line:\n$_\n");
     }
   if (!$gname && $lnum=~m/gene_id[= ]+(['"\:\w\.\|\-]+)/) {
      $gname=$1;
      $gname=~tr/"//d; #"
      }
   $tdescr='' if index($recID, $tdescr)>=0;
   $gname='' if index($recID, $gname)>=0;
   $recID=$chr.'|'.$recID;
   my $ld = $recs->{$recID};
   if ($ld) { #existing entry
     my $i=($f eq 'CDS') ? 7 : 6;
     my ($lstart, $lend)=($$ld[4], $$ld[5]);
     $$ld[4]=$fstart if $fstart<$lstart;
     $$ld[5]=$fend if $fend>$lend;
     push(@{$$ld[$i]}, [$fstart, $fend, $fscore, $frame]);
     if ($f ne 'CDS') {
        if ($$ld[11] && $$ld[11] ne $f) {
           die("Error: multiple non-CDS subfeatures found for $recID ($$ld[11], $f)\n");
           }
        $$ld[11]=$f;
        }
     }
    else { # first time seeing this locus/gene
     # get the attributes from this first exon line
     if ($gff3_Parent) { #has GFF3 Parent
       foreach my $a (@av) {
           my ($attr, $value)=split(/\s*=\s*/,$a,2); #"
           $attr='ID' if $attr eq 'Parent';
           $value=~s/[" ]+$//;$value=~s/^[" ]+//;
           }
        }
      else { # GTF
       foreach my $a (@av) {
           my ($attr, $value)=split(/\s+"/,$a,2); #"
           $value=~s/[" ]+$//;
           if ($attr eq 'transcript_id') {
                     $attr='ID';
                     }
                  elsif ($attr eq 'gene_id') {
                     $attr='Name';
                     }
           $attrs{$attr}=$value unless $attr=~m/^exon/;;
           }
       }
     $recs->{$recID} = ($f eq 'CDS') ? 
           [$chr, $strand, $f, {%attrs}, $fstart, $fend,          [],      [[$fstart, $fend, $fscore, $frame]], $isGFF3, $rejected, $track, '','.' ] :
           [$chr, $strand, $f, {%attrs}, $fstart, $fend, [[$fstart, $fend, $fscore, $frame]], [],               $isGFF3, $rejected, $track, $f,'.' ] ;
         #   0       1      2     3        4       5       6(exons)                          7 (CDS)              8          9        10
     }
 }
}

sub processGffRecs {
 #return if keys(%recs)==0;
 my ($recs, $rlist)=@_;
 my @recs_keys;
 unless ($rlist) {
   @recs_keys=keys(%$recs);
   $rlist=\@recs_keys;
 }
 my $lastchr; #to detect chr change
 my $dshift=0;
 foreach my $recid (@$rlist) {
   my $td=$$recs{$recid};
   #     0       1       2        3        4      5       6    7     8        9     10      11     12
   my ($chr, $strand, $feature, $attrs, $fstart, $fend,  $er, $cr, $isGFF3, $rej, $track, $subf, $fscore) = @$td;
   my $newchr=($chr ne $lastchr);
   if ($newchr) {
      $dshift=0;
      $lastchr=$chr;
   }
   next if ($rej && !$fltinvert);
   next if ($fltinvert && $featlist && !$rej);
   # my ($mstart,$mend)=($fstart, $fend);
   my $CDSonly=0; # set to 1 if only CDS segments were given
   my $hasCDS=0;
   my @ex;
   my @cds;
   #some records might lack exons, but have only CDS segments (e.g. mitochondrial genes)
   if (@$er<1 && @$cr>0) {
     @ex = sort { $a->[0] <=> $b->[0] } @$cr;
     @cds=@ex;
     $CDSonly=1;
     $hasCDS=1;
   } else {
     @ex = sort { $a->[0] <=> $b->[0] } @$er;
     if (@$cr>0) { # sort cds segments too
       @cds= sort { $a->[0] <=> $b->[0] } @$cr;
       $hasCDS=1;
     }
   }
   # --------------
   # get the more accurate version of the start-end coords for the feature
   my $covlen=0;
   # map { $covlen+=$_->[1]-$_->[0]+1 } @ex;
   my ($mstart, $mend) = ($ex[0]->[0], $ex[-1]->[1]);
   my $gffid=$recid;
   substr($gffid, 0, length($chr)+1)='';
   die("Error: gffid ($gffid) not matching attrs\{ID\}(".$attrs->{'ID'}.")!\n")
       unless ($gffid eq $attrs->{'ID'});
   my $doprint=1;
   #check all the filters
   $doprint=0 if ($only_ifCDS && $hasCDS==0);
   if ($doprint && $idfile) {
     if ($idfileattr) {
        $doprint=0 unless exists($idflt{$attrs->{$idfileattr}});
        }
      else {
        $doprint=0 unless exists($idflt{$gffid});
        }
     }
    if ($doprint && $avflt) {
      my $avfound=0;
      if ($avflt_all) {
        #all attributes must be present and match
        $avfound=1;
        foreach my $a (keys(%attrflt)) {
          my $v=$attrs->{$a};
          if (!$v || $attrflt{$a} ne $v) {
            $avfound=0;
            last;
          }
        }
      } else {
        foreach my $a (keys(%attrflt)) {
          if ($attrflt{$a} eq $attrs->{$a}) {
            $avfound=1;
            last;
          }
        }
      }
      $doprint=0 if !$avfound;
    }
  if ($doprint && $flt_chr && $flt_chr ne $chr) {
    $doprint=0;
    }
  if ($doprint) {
    if ($flt_strand && $flt_strand ne $strand) {
      $doprint=0;
    }
  }
  if ($doprint && @flt_intv>0) {
    if ($exon_ovl) { #t span overlap any range intervals
       for my $ed (@ex) {
         if (checkOvlExons($$ed[0], $$ed[1], \@flt_intv)) {
            $doprint=1;
            last;
            }
         }
    } elsif ($strict_ovl) {
       $doprint=1 if checkOvlWithin($fstart, $fend, \@flt_intv);
    } else {
      $doprint=1 if checkOvlExons($fstart, $fend, \@flt_intv);
    }
  }
  $doprint = ! $doprint if $fltinvert;
  next unless $doprint;
  #filter passed, print output
  if ($tab_attrs) {
     my @od;
     foreach my $a (@atab_cols) {
       if (uc($a) eq 'ID') {
          push(@od, $gffid);
          next;
          }
       push(@od, $attrs->{$a});
       }
     print join("\t",@od)."\n";
     next;
     }
   #the core attributes ID, Name must be there already
   unless (exists($attrs->{Name})) {
     foreach my $name (qw(gene_name gene geneID geneId geneid locus loc ID)) {
       if (exists($attrs->{$name})) {
           $attrs->{Name}=$attrs->{$name};
           last;
           }
          }
     }
   my ($tid, $tname)= (delete($attrs->{ID}), delete($attrs->{Name}));
   my ($gene_name, $gene, $locus);
   unless ($keepAll) {
     if (exists($attrs->{gene_name})) {
          $gene_name=delete($attrs->{gene_name});
          $gene_name=undef if ($gene_name eq $tname && !exists($oattrs{gene_name}));
          }
     if (exists($attrs->{gene})) {
          $gene=delete($attrs->{gene});
          $gene=undef if ($gene eq $tname || $gene eq $gene_name) && !exists($oattrs{gene});
          }
     if (exists($attrs->{locus})) {
          $locus=delete($attrs->{locus});
          $locus=undef if ($locus eq $gene_name || $locus eq $gene_name) && !exists($oattrs{locus});
          }
     }
   my $tattrs;  
   if ($printGTF) { #print GTF
     $tattrs='transcript_id "'.$tid.'"; gene_id "'.$tname.'";';
     $tattrs.=' gene_name "'.$gene_name.'";' if $gene_name;
     $tattrs.=' gene "'.$gene.'";' if $gene;
     $tattrs.=' locus "'.$locus.'";' if $locus;
     if ($keepAll) {
        foreach my $attr (keys(%$attrs)) {
           $tattrs.=' '.$attr.' "'.$attrs->{$attr}.'";';
           }
        }
       else { # only a subset of attributes will be shown
        foreach my $attr (keys(%$attrs)) {
           next unless exists($oattrs{$attr});
           $tattrs.=' '.$attr.' "'.$attrs->{$attr}.'";';
           }
        }
     }
    else { #print GFF3
     $tattrs='Parent='.$tid;
     my $pattrs="ID=$tid;Name=$tname";
     $pattrs.='gene_name='.$gene_name.';' if $gene_name;
     $pattrs.='gene='.$gene.';' if $gene;
     $pattrs.='locus='.$locus.';' if $locus;
     if ($keepAll) {
        foreach my $attr (keys(%$attrs)) {
           my $val=$attrs->{$attr};
           $pattrs.="$attr=$val;";
           }
        }
       else { # only a subset of attributes will be shown
        foreach my $attr (keys(%$attrs)) {
           next unless exists($oattrs{$attr});
           my $val=$attrs->{$attr};
           $pattrs.="$attr=$val;";
           }
        }
     print join("\t",$chr, $track, $feature, $fstart, $fend, $fscore, $strand, '.', $pattrs)."\n";
     }
   if ($CDSonly==0) { #write exons only when found in the input
        foreach my $ed (@ex) {
            print join("\t",$chr, $track, $subf, $$ed[0], $$ed[1], $$ed[2], $strand, $$ed[3], $tattrs)."\n";
            }
        }
   foreach my $cd (@cds) {
            print join("\t",$chr, $track, 'CDS', $$cd[0], $$cd[1], $$cd[2], $strand, $$cd[3], $tattrs)."\n";
            }
 } #for each stored transcript
}

